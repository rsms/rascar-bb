// Cradlepoint CTR-35
"use strict";
var http = require('http');
var crypto = require('crypto');

// http://192.168.0.1/api/tree/status?q=$.wan&q=$.wlan.clients&q=$.dhcpd.leases&_dc=1345005179278
// http://192.168.0.1/api/tree/status?q=$.wan&q=$.wlan.clients&q=$.dhcpd.leases&_dc=1345005187173

function HD(typename, data) {
  return crypto.createHash(typename).update(data, 'utf8').digest('hex');
}

function parse_digest_auth_req(raw) {
  // Digest realm="CTR35", nonce="067dfca4dfa79661df43e76b74e2d033", algorithm="MD5", qop="auth"
  if (!raw) return null;
  var req = {}, m, re = /([a-zA-Z0-9_]+)="([^"]+)"/g;
  while (m = re.exec(raw))
    req[m[1]] = m[2];
  return req;
}

function Session(values) {
  var props = {
    clientNonce: {value: HD('md5', String(new Date)+':ctr35')},
  };
  Object.keys(values).forEach(function (k) {
    props[k] = {value: values[k]};
  });
  var obj = Object.create(Session.prototype, props);
  obj.nonceCount = 0;
  return obj;
}
exports.Session = Session;
Session.prototype = {

  makeDigestAuthHeaderValue: function (httpMethod, reqURI) {
    var ar = this.authReq;
    if (!ar) return null;
    var res = {}, i, h2, h1 = HD(ar.algorithm,
      this.username + ':' + ar.realm + ':' + this.password);

    if (!ar.qop || ar.qop === 'auth') {
      h2 = HD(ar.algorithm, httpMethod + ':' + reqURI);
    } else {
      return null; // auth-int not yet supported
    }

    if (ar.qop === 'auth' || ar.qop === 'auth-int') {
      this.nonceCount++;
      
      res.cnonce = this.clientNonce;
      res.nc = this.nonceCount.toString(16);
      while (res.nc.length < 8)
        res.nc = '0'+res.nc;

      res.response = HD(ar.algorithm,
        [h1, ar.nonce, res.nc, res.cnonce, ar.qop, h2].join(':'));
    } else {
      res.response = HD(ar.algorithm, [h1, ar.nonce, h2].join(':'));
    }

    res.username = this.username;
    res.realm = ar.realm;
    res.nonce = ar.nonce;
    res.uri = reqURI;
    res.qop = ar.qop;
    if (ar.opaque) res.opaque = ar.opaque;
    if (ar.algorithm) res.algorithm = ar.algorithm;

    // Digest
    //   username="admin",
    //   realm="CTR35",
    //   nonce="b7280595d04c44ea343af451cb146a47",
    //   uri="/api/tree/status",
    //   cnonce="MTM0NTAx",
    //   nc=00000001,
    //   qop="auth",
    //   response="36c52e58c8d86c2510ce323db45a896d",
    //   algorithm="MD5"

    return 'Digest ' + Object.keys(res).map(function (k) {
      if (k === 'nc') {
        return k + '=' + res[k];
      } else {
        return k + '="' + String(res[k]).replace(/"/g, '\\"') + '"';
      }
    }).join(', ');
  },

  // Authorization: Digest username="Mufasa",
  //                    realm="testrealm@host.com",
  //                    nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
  //                    uri="/dir/index.html",
  //                    qop=auth,
  //                    nc=00000001,
  //                    cnonce="0a4f113b",
  //                    response="6629fae49393a05397450978507c4ef1",
  //                    opaque="5ccc069c403ebaf9f0171e9517f40e41"


  status: function(q, callback, _is_auth_response) {
    var self = this, ctx = {};
    var opt = {hostname:'192.168.0.1', method:'GET', path:'/api/tree/status'};

    if (q && q instanceof Array)
      opt.path += '?' + q.map(function (s) { return 'q=$.'+s; }).join('&');
    //console.log('opt.path:', opt.path);

    var authHeaderValue = this.makeDigestAuthHeaderValue(opt.method, opt.path);
    if (authHeaderValue)
      opt.headers = {'Authorization': authHeaderValue};
    //console.log('opt.headers ->', opt.headers);

    http.get(opt, function (res) {
      var responseData = '';
      //console.log('STATUS: ' + res.statusCode);
      //console.log('HEADERS: ' + JSON.stringify(res.headers));

      // Handle authentication
      if (res.statusCode === 401) {
        if (_is_auth_response) {
          return callback(Error('not authorized'));
        } else {
          self.authReq = parse_digest_auth_req(res.headers['www-authenticate']);
          // Retry with auth
          return self.status(q, callback, true);
        }

      } else if (res.statusCode !== 200) {
        return callback(Error('HTTP '+res.statusCode));

      } else {
        res.setEncoding('utf8');
        res.on('data', function (chunk) { responseData += chunk; });
        res.on('end', function () {
          var err;
          //try { responseData = JSON.parse(responseData); } catch (e) { err = e; }
          callback(err, responseData);
        });
      }

    }).on('error', function (e) {
      if (ctx.error_is_timeout)
        e.message = 'timeout';
      callback(e);
    }).setTimeout(10000, function (e) {
      ctx.error_is_timeout = true;
      this.connection.destroy();
    });
  },

};
